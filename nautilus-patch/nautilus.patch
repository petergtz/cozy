Gemeinsame Unterverzeichnisse: nautilus-2.24.1.orig/src/file-manager und nautilus-2.24.1/src/file-manager.
diff -wN nautilus-2.24.1.orig/src/Makefile.am nautilus-2.24.1/src/Makefile.am
15a16
> 	-I`pkg-config --cflags dbus-glib-1`
32a34
>     `pkg-config --libs dbus-glib-1`
diff -wN nautilus-2.24.1.orig/src/nautilus-application.c nautilus-2.24.1/src/nautilus-application.c
86a87,89
> #include <dbus/dbus-glib.h>
> #include "nautilus-application-dbus-binding.h"
> 
533a537,568
> gboolean
> nautilus_application_dbus_get_window_list (NautilusApplication *application, char ***ret, GError **error)
> {
> 	  GList *cursor;
> 	  int i;
> 	  int n_windows;
> 	  n_windows = g_list_length(nautilus_application_get_window_list());
> 	  *ret = g_new(char*, n_windows+1);
> 
> 	  cursor = nautilus_application_get_window_list();
> 	  i = 0;
> 	  while((cursor != NULL) && (i<n_windows))
> 	  {
> 		  (*ret)[i] = g_strdup_printf("/NautilusWindow/%i", (guint)cursor->data);
> 		  cursor = cursor->next;
> 		  i++;
> 	  }
> 	  (*ret)[i] = NULL;
> 	  return TRUE;
> }
> 
> gboolean nautilus_application_dbus_create_navigation_window (NautilusApplication *application, char **ret, GError **error)
> {
> 
> 	NautilusWindow *window;
> 	window = nautilus_application_create_navigation_window (application, NULL, gdk_screen_get_default ());
> 	*ret = g_strdup_printf("/NautilusWindow/%i", (guint)window);
> //	gtk_widget_show(window);
> 	return TRUE;
> }
> 
> 
555a591,597
> 	DBusGConnection *bus;
> 	GError *error;
> 	DBusGProxy *bus_proxy;
> 	guint request_name_result;
> 	char **name_list;
> 	char **name_list_ptr;
> 
566a609,626
> 	dbus_g_object_type_install_info(NAUTILUS_TYPE_APPLICATION, &dbus_glib_nautilus_application_object_info);
> 
> 	bus = dbus_g_bus_get (DBUS_BUS_SESSION, &error);
> 	bus_proxy = dbus_g_proxy_new_for_name(bus, DBUS_SERVICE_DBUS, DBUS_PATH_DBUS, DBUS_INTERFACE_DBUS);
> 
> 	if (!dbus_g_proxy_call (bus_proxy, "RequestName", &error,
> 			  G_TYPE_STRING, "org.gnome.Nautilus",
> 			  G_TYPE_UINT, 0,
> 			  G_TYPE_INVALID,
> 			  G_TYPE_UINT, &request_name_result,
> 			  G_TYPE_INVALID))
> 	{
> 		g_printerr ("Failed to acquire org.gnome.Nautilus", error);
> 	}
> 
> 	dbus_g_object_type_install_info(NAUTILUS_TYPE_APPLICATION, &dbus_glib_nautilus_application_object_info);
> 	dbus_g_connection_register_g_object (bus, "/NautilusApplication", G_OBJECT (application));
> 
diff -wN nautilus-2.24.1.orig/src/nautilus-application-dbus-binding.h nautilus-2.24.1/src/nautilus-application-dbus-binding.h
0a1,121
> /* Generated by dbus-binding-tool; do not edit! */
> 
> 
> #ifndef __dbus_glib_marshal_nautilus_application_MARSHAL_H__
> #define __dbus_glib_marshal_nautilus_application_MARSHAL_H__
> 
> #include	<glib-object.h>
> 
> G_BEGIN_DECLS
> 
> #ifdef G_ENABLE_DEBUG
> #define g_marshal_value_peek_boolean(v)  g_value_get_boolean (v)
> #define g_marshal_value_peek_char(v)     g_value_get_char (v)
> #define g_marshal_value_peek_uchar(v)    g_value_get_uchar (v)
> #define g_marshal_value_peek_int(v)      g_value_get_int (v)
> #define g_marshal_value_peek_uint(v)     g_value_get_uint (v)
> #define g_marshal_value_peek_long(v)     g_value_get_long (v)
> #define g_marshal_value_peek_ulong(v)    g_value_get_ulong (v)
> #define g_marshal_value_peek_int64(v)    g_value_get_int64 (v)
> #define g_marshal_value_peek_uint64(v)   g_value_get_uint64 (v)
> #define g_marshal_value_peek_enum(v)     g_value_get_enum (v)
> #define g_marshal_value_peek_flags(v)    g_value_get_flags (v)
> #define g_marshal_value_peek_float(v)    g_value_get_float (v)
> #define g_marshal_value_peek_double(v)   g_value_get_double (v)
> #define g_marshal_value_peek_string(v)   (char*) g_value_get_string (v)
> #define g_marshal_value_peek_param(v)    g_value_get_param (v)
> #define g_marshal_value_peek_boxed(v)    g_value_get_boxed (v)
> #define g_marshal_value_peek_pointer(v)  g_value_get_pointer (v)
> #define g_marshal_value_peek_object(v)   g_value_get_object (v)
> #else /* !G_ENABLE_DEBUG */
> /* WARNING: This code accesses GValues directly, which is UNSUPPORTED API.
>  *          Do not access GValues directly in your code. Instead, use the
>  *          g_value_get_*() functions
>  */
> #define g_marshal_value_peek_boolean(v)  (v)->data[0].v_int
> #define g_marshal_value_peek_char(v)     (v)->data[0].v_int
> #define g_marshal_value_peek_uchar(v)    (v)->data[0].v_uint
> #define g_marshal_value_peek_int(v)      (v)->data[0].v_int
> #define g_marshal_value_peek_uint(v)     (v)->data[0].v_uint
> #define g_marshal_value_peek_long(v)     (v)->data[0].v_long
> #define g_marshal_value_peek_ulong(v)    (v)->data[0].v_ulong
> #define g_marshal_value_peek_int64(v)    (v)->data[0].v_int64
> #define g_marshal_value_peek_uint64(v)   (v)->data[0].v_uint64
> #define g_marshal_value_peek_enum(v)     (v)->data[0].v_long
> #define g_marshal_value_peek_flags(v)    (v)->data[0].v_ulong
> #define g_marshal_value_peek_float(v)    (v)->data[0].v_float
> #define g_marshal_value_peek_double(v)   (v)->data[0].v_double
> #define g_marshal_value_peek_string(v)   (v)->data[0].v_pointer
> #define g_marshal_value_peek_param(v)    (v)->data[0].v_pointer
> #define g_marshal_value_peek_boxed(v)    (v)->data[0].v_pointer
> #define g_marshal_value_peek_pointer(v)  (v)->data[0].v_pointer
> #define g_marshal_value_peek_object(v)   (v)->data[0].v_pointer
> #endif /* !G_ENABLE_DEBUG */
> 
> 
> /* BOOLEAN:POINTER,POINTER (/tmp/dbus-binding-tool-c-marshallers.F19A1U:1) */
> extern void dbus_glib_marshal_nautilus_application_BOOLEAN__POINTER_POINTER (GClosure     *closure,
>                                                                              GValue       *return_value,
>                                                                              guint         n_param_values,
>                                                                              const GValue *param_values,
>                                                                              gpointer      invocation_hint,
>                                                                              gpointer      marshal_data);
> void
> dbus_glib_marshal_nautilus_application_BOOLEAN__POINTER_POINTER (GClosure     *closure,
>                                                                  GValue       *return_value G_GNUC_UNUSED,
>                                                                  guint         n_param_values,
>                                                                  const GValue *param_values,
>                                                                  gpointer      invocation_hint G_GNUC_UNUSED,
>                                                                  gpointer      marshal_data)
> {
>   typedef gboolean (*GMarshalFunc_BOOLEAN__POINTER_POINTER) (gpointer     data1,
>                                                              gpointer     arg_1,
>                                                              gpointer     arg_2,
>                                                              gpointer     data2);
>   register GMarshalFunc_BOOLEAN__POINTER_POINTER callback;
>   register GCClosure *cc = (GCClosure*) closure;
>   register gpointer data1, data2;
>   gboolean v_return;
> 
>   g_return_if_fail (return_value != NULL);
>   g_return_if_fail (n_param_values == 3);
> 
>   if (G_CCLOSURE_SWAP_DATA (closure))
>     {
>       data1 = closure->data;
>       data2 = g_value_peek_pointer (param_values + 0);
>     }
>   else
>     {
>       data1 = g_value_peek_pointer (param_values + 0);
>       data2 = closure->data;
>     }
>   callback = (GMarshalFunc_BOOLEAN__POINTER_POINTER) (marshal_data ? marshal_data : cc->callback);
> 
>   v_return = callback (data1,
>                        g_marshal_value_peek_pointer (param_values + 1),
>                        g_marshal_value_peek_pointer (param_values + 2),
>                        data2);
> 
>   g_value_set_boolean (return_value, v_return);
> }
> 
> G_END_DECLS
> 
> #endif /* __dbus_glib_marshal_nautilus_application_MARSHAL_H__ */
> 
> #include <dbus/dbus-glib.h>
> static const DBusGMethodInfo dbus_glib_nautilus_application_methods[] = {
>   { (GCallback) nautilus_application_dbus_get_window_list, dbus_glib_marshal_nautilus_application_BOOLEAN__POINTER_POINTER, 0 },
>   { (GCallback) nautilus_application_dbus_create_navigation_window, dbus_glib_marshal_nautilus_application_BOOLEAN__POINTER_POINTER, 63 },
> };
> 
> const DBusGObjectInfo dbus_glib_nautilus_application_object_info = {
>   0,
>   dbus_glib_nautilus_application_methods,
>   2,
> "org.gnome.NautilusApplication\0get_window_list\0S\0arg0\0O\0F\0N\0as\0\0org.gnome.NautilusApplication\0create_navigation_window\0S\0arg0\0O\0F\0N\0o\0\0\0",
> "\0",
> "\0"
> };
> 
diff -wN nautilus-2.24.1.orig/src/nautilus-application.h nautilus-2.24.1/src/nautilus-application.h
107a108,110
> 
> gboolean	     nautilus_application_dbus_get_window_list (NautilusApplication *application, char ***ret, GError **error);
> gboolean	     nautilus_application_dbus_create_navigation_window (NautilusApplication *application, char **ret, GError **error);
diff -wN nautilus-2.24.1.orig/src/nautilus-application.xml nautilus-2.24.1/src/nautilus-application.xml
0a1,17
> <?xml version="1.0" encoding="UTF-8" ?>
> 
> <node name="/">
>   <interface name="org.gnome.NautilusApplication">
>   
>     <method name="get_window_list">
>       <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="nautilus_application_dbus_get_window_list"/>
>       <arg type="as" direction="out"/> 
>     </method>
> 
>     <method name="create_navigation_window">
>       <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="nautilus_application_dbus_create_navigation_window"/>
>       <arg type="o" direction="out"/> 
>     </method>
> 
>   </interface>
> </node>
diff -wN nautilus-2.24.1.orig/src/nautilus-window.c nautilus-2.24.1/src/nautilus-window.c
70a71,72
> #include "nautilus-window-dbus-binding.h"
> 
141a144,173
> static void enter_restore_mode_event(DBusGProxy *object, gpointer user_data)
> {
> 	DBusGConnection *bus;
> 	gchar dbus_window_as_string[1000];
> 	DBusGProxy *cozy_control_center;
> 	GError *error = NULL;
> 	gint result;
> 	g_print("Received a signal from Cozy Restore Control Center\n");
> 	if (gtk_window_has_toplevel_focus(GTK_WINDOW(user_data)))
> 	{
> 		g_print("Registering myself, because I'm the toplevel window with the focus.");
> 		bus = dbus_g_bus_get (DBUS_BUS_SESSION, &error);
> 		cozy_control_center = dbus_g_proxy_new_for_name(bus, "org.freedesktop.Cozy", "/org/freedesktop/Cozy/RestoreControlCenter",
> 								"org.freedesktop.Cozy.RestoreControlCenter");
> 		g_sprintf(dbus_window_as_string, "/NautilusWindow/%i", GTK_WINDOW(user_data));
> 		result = dbus_g_proxy_call(cozy_control_center, "register_me", &error,
> 				G_TYPE_STRING, dbus_window_as_string,
> 				G_TYPE_STRING, "org.gnome.NautilusWindow",
> 				G_TYPE_STRING, "go_to",
> 				G_TYPE_STRING, "get_location_uri",
> 				G_TYPE_INVALID,
> 				G_TYPE_INVALID);
> 		if (!result)
> 		{
> 			g_printerr ("Error: Could not register myself at Cozy Control Center due to:\n%s\n", error->message);
> 		}
> 	}
> 
> }
> 
147a180,183
> 	gchar dbus_window_as_string[1000];
> 	DBusGConnection *bus;
> 	DBusGProxy *cozy_control_center;
> 	GError *error = NULL;
192a229,239
> 
> 	bus = dbus_g_bus_get (DBUS_BUS_SESSION, &error);
> 	dbus_g_object_type_install_info(NAUTILUS_TYPE_WINDOW, &dbus_glib_nautilus_window_object_info);
> 	g_sprintf(dbus_window_as_string, "/NautilusWindow/%i", window);
> 	dbus_g_connection_register_g_object (bus, dbus_window_as_string, G_OBJECT (window));
> 	cozy_control_center = dbus_g_proxy_new_for_name(bus, "org.freedesktop.Cozy", "/org/freedesktop/Cozy/RestoreControlCenter",
> 							"org.freedesktop.Cozy.RestoreControlCenter");
> 	dbus_g_proxy_add_signal(cozy_control_center, "enter_restore_mode_event", G_TYPE_INVALID);
> 	dbus_g_proxy_connect_signal(cozy_control_center, "enter_restore_mode_event", G_CALLBACK(enter_restore_mode_event), window, NULL);
> 
> 
1907a1955,2001
> 
> gboolean
> nautilus_window_dbus_go_to (NautilusWindow *window, const char *location, GError **error)
> {
> 	GFile *file_location;
> 	file_location = g_file_new_for_uri(location);
> 	nautilus_window_go_to(window, file_location);
> 	return TRUE;
> }
> 
> gboolean nautilus_window_dbus_go_up (NautilusWindow    *window,
> 						       GError **error)
> {
> 	nautilus_window_go_up(window, FALSE, FALSE);
> 	return TRUE;
> }
> gboolean nautilus_window_dbus_get_location_uri (NautilusWindow    *window,
> 						       char             **location,
> 						       GError **error)
> {
> 	*location = g_strdup(nautilus_window_slot_get_location_uri(window->details->active_slot));
> 	return TRUE;
> }
> 
> gboolean nautilus_window_dbus_go_to_with_selection (NautilusWindow    *window,
> 						       const char             *location_uri,
> 						       const char** selection_uris,
> 						       GError **error)
> {
> //	nautilus_window_slot_go_to_with_selection(window->details->active_slot, location, selection);
> 	return TRUE;
> }
> 
> gboolean nautilus_window_dbus_close (NautilusWindow *window, GError **error)
> {
> 	nautilus_window_close(window);
> 	return TRUE;
> }
> 
> gboolean
> nautilus_window_dbus_go_to_version (NautilusWindow    *window,
> 					const gint	*version,
> 					GError **error)
> {
> 	return TRUE;
> }
> 
diff -wN nautilus-2.24.1.orig/src/nautilus-window-dbus-binding.h nautilus-2.24.1/src/nautilus-window-dbus-binding.h
0a1,313
> /* Generated by dbus-binding-tool; do not edit! */
> 
> 
> #ifndef __dbus_glib_marshal_nautilus_window_MARSHAL_H__
> #define __dbus_glib_marshal_nautilus_window_MARSHAL_H__
> 
> #include	<glib-object.h>
> 
> G_BEGIN_DECLS
> 
> #ifdef G_ENABLE_DEBUG
> #define g_marshal_value_peek_boolean(v)  g_value_get_boolean (v)
> #define g_marshal_value_peek_char(v)     g_value_get_char (v)
> #define g_marshal_value_peek_uchar(v)    g_value_get_uchar (v)
> #define g_marshal_value_peek_int(v)      g_value_get_int (v)
> #define g_marshal_value_peek_uint(v)     g_value_get_uint (v)
> #define g_marshal_value_peek_long(v)     g_value_get_long (v)
> #define g_marshal_value_peek_ulong(v)    g_value_get_ulong (v)
> #define g_marshal_value_peek_int64(v)    g_value_get_int64 (v)
> #define g_marshal_value_peek_uint64(v)   g_value_get_uint64 (v)
> #define g_marshal_value_peek_enum(v)     g_value_get_enum (v)
> #define g_marshal_value_peek_flags(v)    g_value_get_flags (v)
> #define g_marshal_value_peek_float(v)    g_value_get_float (v)
> #define g_marshal_value_peek_double(v)   g_value_get_double (v)
> #define g_marshal_value_peek_string(v)   (char*) g_value_get_string (v)
> #define g_marshal_value_peek_param(v)    g_value_get_param (v)
> #define g_marshal_value_peek_boxed(v)    g_value_get_boxed (v)
> #define g_marshal_value_peek_pointer(v)  g_value_get_pointer (v)
> #define g_marshal_value_peek_object(v)   g_value_get_object (v)
> #else /* !G_ENABLE_DEBUG */
> /* WARNING: This code accesses GValues directly, which is UNSUPPORTED API.
>  *          Do not access GValues directly in your code. Instead, use the
>  *          g_value_get_*() functions
>  */
> #define g_marshal_value_peek_boolean(v)  (v)->data[0].v_int
> #define g_marshal_value_peek_char(v)     (v)->data[0].v_int
> #define g_marshal_value_peek_uchar(v)    (v)->data[0].v_uint
> #define g_marshal_value_peek_int(v)      (v)->data[0].v_int
> #define g_marshal_value_peek_uint(v)     (v)->data[0].v_uint
> #define g_marshal_value_peek_long(v)     (v)->data[0].v_long
> #define g_marshal_value_peek_ulong(v)    (v)->data[0].v_ulong
> #define g_marshal_value_peek_int64(v)    (v)->data[0].v_int64
> #define g_marshal_value_peek_uint64(v)   (v)->data[0].v_uint64
> #define g_marshal_value_peek_enum(v)     (v)->data[0].v_long
> #define g_marshal_value_peek_flags(v)    (v)->data[0].v_ulong
> #define g_marshal_value_peek_float(v)    (v)->data[0].v_float
> #define g_marshal_value_peek_double(v)   (v)->data[0].v_double
> #define g_marshal_value_peek_string(v)   (v)->data[0].v_pointer
> #define g_marshal_value_peek_param(v)    (v)->data[0].v_pointer
> #define g_marshal_value_peek_boxed(v)    (v)->data[0].v_pointer
> #define g_marshal_value_peek_pointer(v)  (v)->data[0].v_pointer
> #define g_marshal_value_peek_object(v)   (v)->data[0].v_pointer
> #endif /* !G_ENABLE_DEBUG */
> 
> 
> /* BOOLEAN:POINTER,POINTER (/tmp/dbus-binding-tool-c-marshallers.QX1I2U:1) */
> extern void dbus_glib_marshal_nautilus_window_BOOLEAN__POINTER_POINTER (GClosure     *closure,
>                                                                         GValue       *return_value,
>                                                                         guint         n_param_values,
>                                                                         const GValue *param_values,
>                                                                         gpointer      invocation_hint,
>                                                                         gpointer      marshal_data);
> void
> dbus_glib_marshal_nautilus_window_BOOLEAN__POINTER_POINTER (GClosure     *closure,
>                                                             GValue       *return_value G_GNUC_UNUSED,
>                                                             guint         n_param_values,
>                                                             const GValue *param_values,
>                                                             gpointer      invocation_hint G_GNUC_UNUSED,
>                                                             gpointer      marshal_data)
> {
>   typedef gboolean (*GMarshalFunc_BOOLEAN__POINTER_POINTER) (gpointer     data1,
>                                                              gpointer     arg_1,
>                                                              gpointer     arg_2,
>                                                              gpointer     data2);
>   register GMarshalFunc_BOOLEAN__POINTER_POINTER callback;
>   register GCClosure *cc = (GCClosure*) closure;
>   register gpointer data1, data2;
>   gboolean v_return;
> 
>   g_return_if_fail (return_value != NULL);
>   g_return_if_fail (n_param_values == 3);
> 
>   if (G_CCLOSURE_SWAP_DATA (closure))
>     {
>       data1 = closure->data;
>       data2 = g_value_peek_pointer (param_values + 0);
>     }
>   else
>     {
>       data1 = g_value_peek_pointer (param_values + 0);
>       data2 = closure->data;
>     }
>   callback = (GMarshalFunc_BOOLEAN__POINTER_POINTER) (marshal_data ? marshal_data : cc->callback);
> 
>   v_return = callback (data1,
>                        g_marshal_value_peek_pointer (param_values + 1),
>                        g_marshal_value_peek_pointer (param_values + 2),
>                        data2);
> 
>   g_value_set_boolean (return_value, v_return);
> }
> 
> /* BOOLEAN:INT,POINTER (/tmp/dbus-binding-tool-c-marshallers.QX1I2U:2) */
> extern void dbus_glib_marshal_nautilus_window_BOOLEAN__INT_POINTER (GClosure     *closure,
>                                                                     GValue       *return_value,
>                                                                     guint         n_param_values,
>                                                                     const GValue *param_values,
>                                                                     gpointer      invocation_hint,
>                                                                     gpointer      marshal_data);
> void
> dbus_glib_marshal_nautilus_window_BOOLEAN__INT_POINTER (GClosure     *closure,
>                                                         GValue       *return_value G_GNUC_UNUSED,
>                                                         guint         n_param_values,
>                                                         const GValue *param_values,
>                                                         gpointer      invocation_hint G_GNUC_UNUSED,
>                                                         gpointer      marshal_data)
> {
>   typedef gboolean (*GMarshalFunc_BOOLEAN__INT_POINTER) (gpointer     data1,
>                                                          gint         arg_1,
>                                                          gpointer     arg_2,
>                                                          gpointer     data2);
>   register GMarshalFunc_BOOLEAN__INT_POINTER callback;
>   register GCClosure *cc = (GCClosure*) closure;
>   register gpointer data1, data2;
>   gboolean v_return;
> 
>   g_return_if_fail (return_value != NULL);
>   g_return_if_fail (n_param_values == 3);
> 
>   if (G_CCLOSURE_SWAP_DATA (closure))
>     {
>       data1 = closure->data;
>       data2 = g_value_peek_pointer (param_values + 0);
>     }
>   else
>     {
>       data1 = g_value_peek_pointer (param_values + 0);
>       data2 = closure->data;
>     }
>   callback = (GMarshalFunc_BOOLEAN__INT_POINTER) (marshal_data ? marshal_data : cc->callback);
> 
>   v_return = callback (data1,
>                        g_marshal_value_peek_int (param_values + 1),
>                        g_marshal_value_peek_pointer (param_values + 2),
>                        data2);
> 
>   g_value_set_boolean (return_value, v_return);
> }
> 
> /* BOOLEAN:STRING,BOXED,POINTER (/tmp/dbus-binding-tool-c-marshallers.QX1I2U:3) */
> extern void dbus_glib_marshal_nautilus_window_BOOLEAN__STRING_BOXED_POINTER (GClosure     *closure,
>                                                                              GValue       *return_value,
>                                                                              guint         n_param_values,
>                                                                              const GValue *param_values,
>                                                                              gpointer      invocation_hint,
>                                                                              gpointer      marshal_data);
> void
> dbus_glib_marshal_nautilus_window_BOOLEAN__STRING_BOXED_POINTER (GClosure     *closure,
>                                                                  GValue       *return_value G_GNUC_UNUSED,
>                                                                  guint         n_param_values,
>                                                                  const GValue *param_values,
>                                                                  gpointer      invocation_hint G_GNUC_UNUSED,
>                                                                  gpointer      marshal_data)
> {
>   typedef gboolean (*GMarshalFunc_BOOLEAN__STRING_BOXED_POINTER) (gpointer     data1,
>                                                                   gpointer     arg_1,
>                                                                   gpointer     arg_2,
>                                                                   gpointer     arg_3,
>                                                                   gpointer     data2);
>   register GMarshalFunc_BOOLEAN__STRING_BOXED_POINTER callback;
>   register GCClosure *cc = (GCClosure*) closure;
>   register gpointer data1, data2;
>   gboolean v_return;
> 
>   g_return_if_fail (return_value != NULL);
>   g_return_if_fail (n_param_values == 4);
> 
>   if (G_CCLOSURE_SWAP_DATA (closure))
>     {
>       data1 = closure->data;
>       data2 = g_value_peek_pointer (param_values + 0);
>     }
>   else
>     {
>       data1 = g_value_peek_pointer (param_values + 0);
>       data2 = closure->data;
>     }
>   callback = (GMarshalFunc_BOOLEAN__STRING_BOXED_POINTER) (marshal_data ? marshal_data : cc->callback);
> 
>   v_return = callback (data1,
>                        g_marshal_value_peek_string (param_values + 1),
>                        g_marshal_value_peek_boxed (param_values + 2),
>                        g_marshal_value_peek_pointer (param_values + 3),
>                        data2);
> 
>   g_value_set_boolean (return_value, v_return);
> }
> 
> /* BOOLEAN:STRING,POINTER (/tmp/dbus-binding-tool-c-marshallers.QX1I2U:4) */
> extern void dbus_glib_marshal_nautilus_window_BOOLEAN__STRING_POINTER (GClosure     *closure,
>                                                                        GValue       *return_value,
>                                                                        guint         n_param_values,
>                                                                        const GValue *param_values,
>                                                                        gpointer      invocation_hint,
>                                                                        gpointer      marshal_data);
> void
> dbus_glib_marshal_nautilus_window_BOOLEAN__STRING_POINTER (GClosure     *closure,
>                                                            GValue       *return_value G_GNUC_UNUSED,
>                                                            guint         n_param_values,
>                                                            const GValue *param_values,
>                                                            gpointer      invocation_hint G_GNUC_UNUSED,
>                                                            gpointer      marshal_data)
> {
>   typedef gboolean (*GMarshalFunc_BOOLEAN__STRING_POINTER) (gpointer     data1,
>                                                             gpointer     arg_1,
>                                                             gpointer     arg_2,
>                                                             gpointer     data2);
>   register GMarshalFunc_BOOLEAN__STRING_POINTER callback;
>   register GCClosure *cc = (GCClosure*) closure;
>   register gpointer data1, data2;
>   gboolean v_return;
> 
>   g_return_if_fail (return_value != NULL);
>   g_return_if_fail (n_param_values == 3);
> 
>   if (G_CCLOSURE_SWAP_DATA (closure))
>     {
>       data1 = closure->data;
>       data2 = g_value_peek_pointer (param_values + 0);
>     }
>   else
>     {
>       data1 = g_value_peek_pointer (param_values + 0);
>       data2 = closure->data;
>     }
>   callback = (GMarshalFunc_BOOLEAN__STRING_POINTER) (marshal_data ? marshal_data : cc->callback);
> 
>   v_return = callback (data1,
>                        g_marshal_value_peek_string (param_values + 1),
>                        g_marshal_value_peek_pointer (param_values + 2),
>                        data2);
> 
>   g_value_set_boolean (return_value, v_return);
> }
> 
> /* BOOLEAN:POINTER (/tmp/dbus-binding-tool-c-marshallers.QX1I2U:5) */
> extern void dbus_glib_marshal_nautilus_window_BOOLEAN__POINTER (GClosure     *closure,
>                                                                 GValue       *return_value,
>                                                                 guint         n_param_values,
>                                                                 const GValue *param_values,
>                                                                 gpointer      invocation_hint,
>                                                                 gpointer      marshal_data);
> void
> dbus_glib_marshal_nautilus_window_BOOLEAN__POINTER (GClosure     *closure,
>                                                     GValue       *return_value G_GNUC_UNUSED,
>                                                     guint         n_param_values,
>                                                     const GValue *param_values,
>                                                     gpointer      invocation_hint G_GNUC_UNUSED,
>                                                     gpointer      marshal_data)
> {
>   typedef gboolean (*GMarshalFunc_BOOLEAN__POINTER) (gpointer     data1,
>                                                      gpointer     arg_1,
>                                                      gpointer     data2);
>   register GMarshalFunc_BOOLEAN__POINTER callback;
>   register GCClosure *cc = (GCClosure*) closure;
>   register gpointer data1, data2;
>   gboolean v_return;
> 
>   g_return_if_fail (return_value != NULL);
>   g_return_if_fail (n_param_values == 2);
> 
>   if (G_CCLOSURE_SWAP_DATA (closure))
>     {
>       data1 = closure->data;
>       data2 = g_value_peek_pointer (param_values + 0);
>     }
>   else
>     {
>       data1 = g_value_peek_pointer (param_values + 0);
>       data2 = closure->data;
>     }
>   callback = (GMarshalFunc_BOOLEAN__POINTER) (marshal_data ? marshal_data : cc->callback);
> 
>   v_return = callback (data1,
>                        g_marshal_value_peek_pointer (param_values + 1),
>                        data2);
> 
>   g_value_set_boolean (return_value, v_return);
> }
> 
> G_END_DECLS
> 
> #endif /* __dbus_glib_marshal_nautilus_window_MARSHAL_H__ */
> 
> #include <dbus/dbus-glib.h>
> static const DBusGMethodInfo dbus_glib_nautilus_window_methods[] = {
>   { (GCallback) nautilus_window_dbus_go_to, dbus_glib_marshal_nautilus_window_BOOLEAN__STRING_POINTER, 0 },
>   { (GCallback) nautilus_window_dbus_go_up, dbus_glib_marshal_nautilus_window_BOOLEAN__POINTER, 43 },
>   { (GCallback) nautilus_window_dbus_get_location_uri, dbus_glib_marshal_nautilus_window_BOOLEAN__POINTER_POINTER, 77 },
>   { (GCallback) nautilus_window_dbus_go_to_with_selection, dbus_glib_marshal_nautilus_window_BOOLEAN__STRING_BOXED_POINTER, 135 },
>   { (GCallback) nautilus_window_dbus_close, dbus_glib_marshal_nautilus_window_BOOLEAN__POINTER, 203 },
>   { (GCallback) nautilus_window_dbus_go_to_version, dbus_glib_marshal_nautilus_window_BOOLEAN__INT_POINTER, 237 },
> };
> 
> const DBusGObjectInfo dbus_glib_nautilus_window_object_info = {
>   0,
>   dbus_glib_nautilus_window_methods,
>   6,
> "org.gnome.NautilusWindow\0go_to\0S\0arg0\0I\0s\0\0org.gnome.NautilusWindow\0go_up\0S\0\0org.gnome.NautilusWindow\0get_location_uri\0S\0arg0\0O\0F\0N\0s\0\0org.gnome.NautilusWindow\0go_to_with_selection\0S\0arg0\0I\0s\0arg1\0I\0as\0\0org.gnome.NautilusWindow\0close\0S\0\0org.freedesktop.Cozy.RestoreClient\0go_to_version\0S\0arg0\0I\0i\0\0\0",
> "\0",
> "\0"
> };
> 
diff -wN nautilus-2.24.1.orig/src/nautilus-window-dbus.c nautilus-2.24.1/src/nautilus-window-dbus.c
0a1,65
> /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*- */
> 
> /*
>  *  Nautilus
>  *
>  *  Copyright (C) 2009 Peter.
>  *
>  *  Nautilus is free software; you can redistribute it and/or
>  *  modify it under the terms of the GNU General Public License as
>  *  published by the Free Software Foundation; either version 2 of the
>  *  License, or (at your option) any later version.
>  *
>  *  Nautilus is distributed in the hope that it will be useful,
>  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
>  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
>  *  General Public License for more details.
>  *
>  *  You should have received a copy of the GNU General Public License
>  *  along with this program; if not, write to the Free Software
>  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
>  *
>  *  Authors: Peter Goetz <p3rg2z@gmail.com>
>  *
>  */
> 
> #include <config.h>
> #include "nautilus-window-dbus.h"
> 
> gboolean
> nautilus_window_dbus_go_to (NautilusWindow *window, const char *location, GError **error)
> {
> 	GFile *file_location;
> 	file_location = g_file_new_for_uri(location);
> 	nautilus_window_go_to(window, file_location);
> 	return TRUE;
> }
> 
> gboolean nautilus_window_dbus_go_up (NautilusWindow    *window,
> 						       GError **error)
> {
> 	nautilus_window_go_up(window, FALSE, FALSE);
> 	return TRUE;
> }
> gboolean nautilus_window_dbus_get_location_uri (NautilusWindow    *window,
> 						       char             **location,
> 						       GError **error)
> {
> 	*location = g_strdup(nautilus_window_slot_get_location_uri(window->details->active_slot));
> 	return TRUE;
> }
> 
> gboolean nautilus_window_dbus_go_to_with_selection (NautilusWindow    *window,
> 						       const char             *location_uri,
> 						       const char** selection_uris,
> 						       GError **error)
> {
> //	nautilus_window_slot_go_to_with_selection(window->details->active_slot, location, selection);
> 	return TRUE;
> }
> 
> gboolean nautilus_window_dbus_close (NautilusWindow *window, GError **error)
> {
> 	nautilus_window_close(window);
> 	return TRUE;
> }
diff -wN nautilus-2.24.1.orig/src/nautilus-window-dbus.h nautilus-2.24.1/src/nautilus-window-dbus.h
0a1,69
> /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*- */
> 
> /*
>  *  Nautilus
>  *
>  *  Copyright (C) 2009 Peter.
>  *
>  *  Nautilus is free software; you can redistribute it and/or
>  *  modify it under the terms of the GNU General Public License as
>  *  published by the Free Software Foundation; either version 2 of the
>  *  License, or (at your option) any later version.
>  *
>  *  Nautilus is distributed in the hope that it will be useful,
>  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
>  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
>  *  General Public License for more details.
>  *
>  *  You should have received a copy of the GNU General Public License
>  *  along with this program; if not, write to the Free Software
>  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
>  *
>  *  Authors: Peter Goetz <p3rg2z@gmail.com>
>  *
>  */
> /* nautilus-window-dbus.h: DBUS-Interface of the main window object */
> 
> #ifndef NAUTILUSWINDOWDBUS_H_
> #define NAUTILUSWINDOWDBUS_H_
> 
> #include "nautilus-window.h"
> #include "nautilus-actions.h"
> #include "nautilus-application.h"
> #include "nautilus-bookmarks-window.h"
> #include "nautilus-information-panel.h"
> #include "nautilus-main.h"
> #include "nautilus-window-manage-views.h"
> #include "nautilus-window-bookmarks.h"
> #include "nautilus-window-slot.h"
> #include "nautilus-navigation-window-slot.h"
> #include "nautilus-zoom-control.h"
> #include "nautilus-search-bar.h"
> #include <eel/eel-debug.h>
> #include <eel/eel-marshal.h>
> #include <eel/eel-gtk-macros.h>
> #include <eel/eel-string.h>
> #include <gdk-pixbuf/gdk-pixbuf.h>
> #include <gdk/gdkx.h>
> #include <gdk/gdkkeysyms.h>
> #include <gtk/gtk.h>
> #include <glib/gi18n.h>
> 
> gboolean         nautilus_window_dbus_go_to           (NautilusWindow    *window,
> 						       const char             *location,
> 						       GError **error);
> gboolean         nautilus_window_dbus_go_up           (NautilusWindow    *window,
> 						       GError **error);
> gboolean         nautilus_window_dbus_get_location_uri  (NautilusWindow    *window,
> 						       char             **location,
> 						       GError **error);
> gboolean         nautilus_window_dbus_go_to_with_selection (NautilusWindow    *window,
> 						       const char             *location_uri,
> 						       const char** selection_uris,
> 						       GError **error);
> gboolean         nautilus_window_dbus_close           (NautilusWindow    *window,
> 						       GError **error);
> 
> 
> 
> #endif /* NAUTILUSWINDOWDBUS_H_ */
diff -wN nautilus-2.24.1.orig/src/nautilus-window.h nautilus-2.24.1/src/nautilus-window.h
159a160,178
> gboolean         nautilus_window_dbus_go_to           (NautilusWindow    *window,
> 						       const char             *location,
> 						       GError **error);
> gboolean         nautilus_window_dbus_go_up           (NautilusWindow    *window,
> 						       GError **error);
> gboolean         nautilus_window_dbus_get_location_uri  (NautilusWindow    *window,
> 						       char             **location,
> 						       GError **error);
> gboolean         nautilus_window_dbus_go_to_with_selection (NautilusWindow    *window,
> 						       const char             *location_uri,
> 						       const char** selection_uris,
> 						       GError **error);
> gboolean         nautilus_window_dbus_close           (NautilusWindow    *window,
> 						       GError **error);
> 
> gboolean	nautilus_window_dbus_go_to_version	(NautilusWindow    *window,
> 						       const gint	*version,
> 						       GError **error);
> 
diff -wN nautilus-2.24.1.orig/src/nautilus-window.xml nautilus-2.24.1/src/nautilus-window.xml
0a1,39
> <?xml version="1.0" encoding="UTF-8" ?>
> 
> <node name="/">
>   <interface name="org.gnome.NautilusWindow">
> 
>     <method name="go_to">
>       <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="nautilus_window_dbus_go_to"/>
>       <arg type="s"/>
>     </method>
> 
>     <method name="go_up">
>       <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="nautilus_window_dbus_go_up"/>
>     </method>
> 
>     <method name="get_location_uri">
>       <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="nautilus_window_dbus_get_location_uri"/>
>       <arg type="s" direction="out"/>
>     </method>
> 
>     <method name="go_to_with_selection">
>       <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="nautilus_window_dbus_go_to_with_selection"/>
>       <arg type="s"/>
>       <arg type="as"/>
>     </method>
> 
>     <method name="close">
>       <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="nautilus_window_dbus_close"/>
>     </method>
> 
>   </interface>
> 
>   <interface name="org.freedesktop.Cozy.RestoreClient">
>     <method name="go_to_version">
>       <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="nautilus_window_dbus_go_to_version"/>
>       <arg type="i"/>
>     </method>
> 
>   </interface>
> </node>
